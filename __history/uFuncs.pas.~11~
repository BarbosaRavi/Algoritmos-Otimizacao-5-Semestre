unit uFuncs;

interface

uses
  System.SysUtils, Vcl.Controls, Vcl.StdCtrls;

type
  TMatrizProblema = TArray<TArray<Integer>>;
  TVetorRota      = TArray<Integer>;

function gerarMatriz(const N: Integer; const fixo: Boolean): TMatrizProblema;
function gerarSolInicial(const D: TMatrizProblema): TVetorRota;
function seguirRota(const R: TVetorRota): TVetorRota;
function avaliarRota(const D: TMatrizProblema; const ciclo: TVetorRota): Integer;
function avaliarRotaComString(const D: TMatrizProblema;const ciclo: TVetorRota;out descricao: string): Integer;
function respToString(const R: TVetorRota): string;
function MatrizToString(const D: TMatrizProblema): string;
function AvaliarPermutacao(const D: TMatrizProblema; const R: TVetorRota): Integer;
procedure TrocarPosicoes(var R: TVetorRota; i, j: Integer);
function GerarVizinhoAleatorio(const R: TVetorRota): TVetorRota;
function SubidaEncosta(const D: TMatrizProblema;const Inicial: TVetorRota; out melhorCusto: Integer): TVetorRota;
function SubidaEncostaTentativas(const D: TMatrizProblema;const Inicial: TVetorRota; tentMax: Integer;out melhorCusto: Integer): TVetorRota;
function TemperaSimulada(const D: TMatrizProblema;const Inicial: TVetorRota; tempIni, tempFim, fatorRed: Double;out melhorCusto: Integer): TVetorRota;


implementation

function AvaliarPermutacao(const D: TMatrizProblema; const R: TVetorRota): Integer;
var
  ciclo: TVetorRota;
begin
  ciclo := seguirRota(R);
  Result := avaliarRota(D, ciclo);
end;

procedure TrocarPosicoes(var R: TVetorRota; i, j: Integer);
var
  aux: Integer;
begin
  aux := R[i];
  R[i] := R[j];
  R[j] := aux;
end;

function GerarVizinhoAleatorio(const R: TVetorRota): TVetorRota;
var
  i, j, N: Integer;
begin
  Result := Copy(R);
  N := Length(Result);

  if N <= 2 then
    Exit;

  repeat
    i := 1 + Random(N - 1);
    j := 1 + Random(N - 1);
  until i <> j;

  TrocarPosicoes(Result, i, j);
end;

function SubidaEncosta(const D: TMatrizProblema;const Inicial: TVetorRota; out melhorCusto: Integer): TVetorRota;
var
  atual, melhorLocal, vizinho: TVetorRota;
  custoAtual, custoVizinho, melhorVizinho: Integer;
  i, j, N: Integer;
  melhorou: Boolean;
begin
  atual := Copy(Inicial);
  N := Length(atual);

  custoAtual := AvaliarPermutacao(D, atual);

  repeat
    melhorou := False;
    melhorVizinho := custoAtual;
    melhorLocal := atual;

    // gera TODOS os vizinhos por troca (swap) de duas posições da rota
    for i := 1 to N - 2 do
      for j := i + 1 to N - 1 do
      begin
        vizinho := Copy(atual);
        TrocarPosicoes(vizinho, i, j);
        custoVizinho := AvaliarPermutacao(D, vizinho);

        if custoVizinho < melhorVizinho then
        begin
          melhorVizinho := custoVizinho;
          melhorLocal := vizinho;
          melhorou := True;
        end;
      end;

    if melhorou then
    begin
      atual := melhorLocal;
      custoAtual := melhorVizinho;
    end;
  until not melhorou;

  Result := atual;
  melhorCusto := custoAtual;
end;


function SubidaEncostaTentativas(const D: TMatrizProblema;const Inicial: TVetorRota; tentMax: Integer;out melhorCusto: Integer): TVetorRota;
var
  atual, melhorGlobal, vizinho: TVetorRota;
  custoAtual, custoVizinho: Integer;
  tentativasSemMelhora: Integer;
begin
  atual := Copy(Inicial);
  melhorGlobal := atual;

  custoAtual := AvaliarPermutacao(D, atual);
  melhorCusto := custoAtual;
  tentativasSemMelhora := 0;

  while tentativasSemMelhora < tentMax do
  begin
    vizinho := GerarVizinhoAleatorio(atual);
    custoVizinho := AvaliarPermutacao(D, vizinho);

    if custoVizinho < custoAtual then
    begin
      // aceitou melhoria
      atual := vizinho;
      custoAtual := custoVizinho;
      tentativasSemMelhora := 0;

      if custoAtual < melhorCusto then
      begin
        melhorCusto := custoAtual;
        melhorGlobal := atual;
      end;
    end
    else
      Inc(tentativasSemMelhora);
  end;

  Result := melhorGlobal;
end;

function TemperaSimulada(const D: TMatrizProblema;const Inicial: TVetorRota; tempIni, tempFim, fatorRed: Double;out melhorCusto: Integer): TVetorRota;
var
  atual, melhorGlobal, vizinho: TVetorRota;
  custoAtual, custoVizinho, delta: Integer;
  T: Double;
  iter, maxIter: Integer;
begin
  Randomize;

  atual := Copy(Inicial);
  melhorGlobal := atual;

  custoAtual := AvaliarPermutacao(D, atual);
  melhorCusto := custoAtual;

  T := tempIni;
  maxIter := Length(atual) * 5;  // número de vizinhos testados por temperatura (ajustável)

  while T > tempFim do
  begin
    for iter := 1 to maxIter do
    begin
      vizinho := GerarVizinhoAleatorio(atual);
      custoVizinho := AvaliarPermutacao(D, vizinho);
      delta := custoVizinho - custoAtual;

      if (delta < 0) or (Exp(-delta / T) > Random) then
      begin
        // aceita o vizinho (melhor ou pior com certa probabilidade)
        atual := vizinho;
        custoAtual := custoVizinho;

        if custoAtual < melhorCusto then
        begin
          melhorCusto := custoAtual;
          melhorGlobal := atual;
        end;
      end;
    end;

    T := T * fatorRed; // resfriamento
  end;

  Result := melhorGlobal;
end;

function avaliarRotaComString(const D: TMatrizProblema;const ciclo: TVetorRota;out descricao: string): Integer;
var
  s, i, custo: Integer;
begin
  s := 0;
  descricao := '';

  for i := 0 to High(ciclo) - 1 do
  begin
    custo := D[ciclo[i], ciclo[i + 1]];

    if i > 0 then
      descricao := descricao + ' + ';

    descricao := descricao
      + ciclo[i].ToString
      + ' -> '
      + ciclo[i + 1].ToString
      + ' (' + custo.ToString + ')';

    Inc(s, custo);
  end;

  // adiciona o total no final
  descricao := descricao + ' = ' + s.ToString;
  Result := s;
end;


// Gera matriz do problema
function gerarMatriz(const N: Integer; const fixo: Boolean): TMatrizProblema;
var
  i, j: Integer;
begin
  SetLength(Result, N, N);

  if fixo and (N = 6) then
  begin
    Result[0] := [0, 14, 7,  8,  12, 6];
    Result[1] := [14, 0, 10, 5,  9,  11];
    Result[2] := [7, 10, 0,  4,  6,  9];
    Result[3] := [8, 5,  4,  0,  7,  3];
    Result[4] := [12, 9,  6,  7,  0,  8];
    Result[5] := [6, 11, 9,  3,  8,  0];
    Exit;
  end;

  if fixo then
    RandSeed := 1234
  else
    Randomize;

  for i := 0 to N - 1 do
    for j := 0 to N - 1 do
      if i = j then
        Result[i, j] := 0
      else if j < i then
        Result[i, j] := Result[j, i]
      else
        Result[i, j] := 2 + Random(49);
end;

//Gera solução inicial

function gerarSolInicialAleatoria(const D: TMatrizProblema): TVetorRota;
var
  N, i, j: Integer;
begin
  N := Length(D);
  SetLength(Result, N);

  // cidade 0 fixa
  Result[0] := 0;
  for i := 1 to N - 1 do
    Result[i] := i;

  // embaralha posições 1..N-1 (Fisher-Yates)
  for i := N - 1 downto 1 do
  begin
    j := 1 + Random(i); // entre 1 e i
    TrocarPosicoes(Result, i, j);
  end;
end;




//function gerarSolInicial(const D: TMatrizProblema): TVetorRota;
//var
//  N, cur, prox, melhorj, melhord, i: Integer;
//  usado: TArray<Boolean>;
//begin
//  N := Length(D);
//  SetLength(Result, N);
//  SetLength(usado, N);
//
//  Result[0] := 0;
//  usado[0]  := True;
//  cur       := 0;
//
//  for i := 1 to N - 1 do
//  begin
//    melhorj := -1;
//    melhord := High(Integer);
//    for prox := 0 to N - 1 do
//      if (not usado[prox]) and (prox <> cur) and (D[cur, prox] < melhord) then
//      begin
//        melhord := D[cur, prox];
//        melhorj := prox;
//      end;
//
//    Result[i]     := melhorj;
//    usado[melhorj]:= True;
//    cur           := melhorj;
//  end;
//end;

//Segue a rota
function seguirRota(const R: TVetorRota): TVetorRota;
var
  N, i: Integer;
begin
  N := Length(R);
  SetLength(Result, N + 1);
  for i := 0 to N - 1 do
    Result[i] := R[i];
  Result[N] := R[0];
end;

//Avalia a rota
function avaliarRota(const D: TMatrizProblema; const ciclo: TVetorRota): Integer;
var
  s, i: Integer;
begin
  s := 0;
  for i := 0 to High(ciclo) - 1 do
    Inc(s, D[ciclo[i], ciclo[i + 1]]);
  Result := s;
end;

//Converte em string para exibir
function respToString(const R: TVetorRota): string;
var
  i: Integer;
begin
  Result := '';
  for i := 0 to High(R) do
  begin
    if i > 0 then
      Result := Result + ' --> ';
    Result := Result + R[i].ToString;
  end;
end;

function MatrizToString(const D: TMatrizProblema): string;
var
  i, j, N: Integer;
  linha: string;
begin
  Result := '';
  N := Length(D);
  for i := 0 to N - 1 do
  begin
    linha := '';
    for j := 0 to N - 1 do
    begin
      if j > 0 then
        linha := linha + #9;
      linha := linha + D[i, j].ToString;
    end;
    Result := Result + linha + sLineBreak;
  end;
end;


end.

